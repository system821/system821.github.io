<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SpringBoot | sptiz's blog</title><meta name="author" content="sptiz"><meta name="copyright" content="sptiz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpringBoot简介 我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot">
<meta property="og:url" content="https://system821.github.io/2025/05/12/SpringBoot/index.html">
<meta property="og:site_name" content="sptiz&#39;s blog">
<meta property="og:description" content="SpringBoot简介 我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://system821.github.io/img/forest_s.png">
<meta property="article:published_time" content="2025-05-12T15:00:28.000Z">
<meta property="article:modified_time" content="2025-10-20T05:57:35.218Z">
<meta property="article:author" content="sptiz">
<meta property="article:tag" content="SpringBoot、框架技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://system821.github.io/img/forest_s.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SpringBoot",
  "url": "https://system821.github.io/2025/05/12/SpringBoot/",
  "image": "https://system821.github.io/img/forest_s.png",
  "datePublished": "2025-05-12T15:00:28.000Z",
  "dateModified": "2025-10-20T05:57:35.218Z",
  "author": [
    {
      "@type": "Person",
      "name": "sptiz",
      "url": "https://system821.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://system821.github.io/2025/05/12/SpringBoot/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringBoot',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/forest_s.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">sptiz's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">SpringBoot</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-12T15:00:28.000Z" title="发表于 2025-05-12 23:00:28">2025-05-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-20T05:57:35.218Z" title="更新于 2025-10-20 13:57:35">2025-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/">框架技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持<span style="background: repeating-linear-gradient(-45deg, #FF000066, #FF000066 4px, #FF634766 4px, #FF634766 8px); padding: 0 4px;"> IoC（Inversion of Control:控制反转）</span> 和 <span style="background: repeating-linear-gradient(-45deg, #FF000066, #FF000066 4px, #FF634766 4px, #FF634766 8px); padding: 0 4px;">AOP(Aspect-Oriented Programming:面向切面编程)</span>、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发</p>
</blockquote>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><h4 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h4><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。</p>
<ul>
<li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li>
<li><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</li>
<li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li>
<li><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li>
</ul>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul>
<li><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</li>
<li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li>
<li><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li>
</ul>
<h4 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access&#x2F;Integration"></a>Data Access&#x2F;Integration</h4><ul>
<li><strong>spring-jdbc</strong>：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li>
<li><strong>spring-tx</strong>：提供对事务的支持。</li>
<li><strong>spring-orm</strong>：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。</li>
<li><strong>spring-oxm</strong>：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li>
<li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li>
</ul>
<h4 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h4><ul>
<li><strong>spring-web</strong>：对 Web 功能的实现提供一些最基础的支持。</li>
<li><strong>spring-webmvc</strong>：提供对 Spring MVC 的实现。</li>
<li><strong>spring-websocket</strong>：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li>
<li><strong>spring-webflux</strong>：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li>
</ul>
<h4 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h4><p><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</p>
<h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h4><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p>
<h3 id="Spring-Spring-MVC-Spring-Boot"><a href="#Spring-Spring-MVC-Spring-Boot" class="headerlink" title="Spring | Spring MVC | Spring Boot"></a>Spring | Spring MVC | Spring Boot</h3><p>Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块</p>
<p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代</p>
<p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p>
<h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p>
<p><strong>为什么叫控制反转？</strong></p>
<ul>
<li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的</p>
<h3 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h3><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类</p>
<h3 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些"></a>将一个类声明为 Bean 的注解有哪些</h3><ul>
<li><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li>
</ul>
<h3 id="Component-Bean"><a href="#Component-Bean" class="headerlink" title="@Component | @Bean"></a>@Component | @Bean</h3><p><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p>
<p><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p>
<p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</p>
<h3 id="注入-Bean-的注解有哪些"><a href="#注入-Bean-的注解有哪些" class="headerlink" title="注入 Bean 的注解有哪些"></a>注入 Bean 的注解有哪些</h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Package</th>
<th>Source</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Autowired</code></td>
<td><code>org.springframework.bean.factory</code></td>
<td>Spring 2.5+</td>
</tr>
<tr>
<td><code>@Resource</code></td>
<td><code>javax.annotation</code></td>
<td>Java JSR-250</td>
</tr>
<tr>
<td><code>@Inject</code></td>
<td><code>javax.inject</code></td>
<td>Java JSR-330</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="comment">// smsServiceImpl1 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure>

<p><span style="background: repeating-linear-gradient(-45deg, #FF000066, #FF000066 4px, #FF634766 4px, #FF634766 8px); padding: 0 4px;">建议通过 <code>@Qualifier</code> 注解来显式指定名称而不是依赖变量的名称</span></p>
<p><span style="background: repeating-linear-gradient(-45deg, #FF000066, #FF000066 4px, #FF634766 4px, #FF634766 8px); padding: 0 4px;"><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解</span></p>
<p><span style="background: repeating-linear-gradient(-45deg, #FF000066, #FF000066 4px, #FF634766 4px, #FF634766 8px); padding: 0 4px;"><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）</span></p>
<p><span style="background: repeating-linear-gradient(-45deg, #FF000066, #FF000066 4px, #FF634766 4px, #FF634766 8px); padding: 0 4px;">当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称</span></p>
<p><span style="background: repeating-linear-gradient(-45deg, #FF000066, #FF000066 4px, #FF634766 4px, #FF634766 8px); padding: 0 4px;"><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用</span></p>
<h3 id="注入Bean的方式"><a href="#注入Bean的方式" class="headerlink" title="注入Bean的方式"></a>注入Bean的方式</h3><p>依赖注入 (Dependency Injection, DI) 的常见方式：</p>
<ol>
<li>构造函数注入：通过类的构造函数来注入依赖项。</li>
<li>Setter 注入：通过类的 Setter 方法来注入依赖项。</li>
<li>Field（字段） 注入：直接在类的字段上使用注解（如 <code>@Autowired</code> 或 <code>@Resource</code>）来注入依赖项。</li>
</ol>
<h3 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>AOP 切面编程涉及到的一些专业术语：</p>
<table>
<thead>
<tr>
<th align="left">术语</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">目标(Target)</td>
<td align="center">被通知的对象</td>
</tr>
<tr>
<td align="left">代理(Proxy)</td>
<td align="center">向目标对象应用通知之后创建的代理对象</td>
</tr>
<tr>
<td align="left">连接点(JoinPoint)</td>
<td align="center">目标对象的所属类中，定义的所有方法均为连接点</td>
</tr>
<tr>
<td align="left">切入点(Pointcut)</td>
<td align="center">被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td>
</tr>
<tr>
<td align="left">通知(Advice)</td>
<td align="center">增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情</td>
</tr>
<tr>
<td align="left">切面(Aspect)</td>
<td align="center">切入点(Pointcut)+通知(Advice)</td>
</tr>
<tr>
<td align="left">Weaving(织入)</td>
<td align="center">将通知应用到目标对象，进而生成代理对象的过程动作</td>
</tr>
</tbody></table>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p><code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合</p>
<h3 id="Spring-Bean-相关"><a href="#Spring-Bean-相关" class="headerlink" title="Spring Bean 相关"></a>Spring Bean 相关</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a><code>@Autowired</code></h4><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p>
<h4 id="Component-Repository-Service-Controller"><a href="#Component-Repository-Service-Controller" class="headerlink" title="@Component,@Repository,@Service, @Controller"></a><code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, @Controller</h4><ul>
<li><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h4 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a><code>@RestController</code></h4><p><code>@RestController</code>注解是<code>@Controller</code>和<code>@ResponseBody</code>的合集,表示这是个控制器 bean,并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器。</p>
<h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a><code>@Scope</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a><code>@Configuration</code></h4><p>一般用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化</p>
<h2 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h2><h4 id="PathVariable-和-RequestParam"><a href="#PathVariable-和-RequestParam" class="headerlink" title="@PathVariable 和 @RequestParam"></a><code>@PathVariable</code> 和 <code>@RequestParam</code></h4><p><code>@PathVariable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getKlassRelatedTeachers</span><span class="params">(</span></span><br><span class="line"><span class="params">         <span class="meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span></span><br><span class="line"><span class="params">         <span class="meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><code>@RequestBody</code></h4><p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application&#x2F;json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign-up&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">signUp</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserRegisterRequest userRegisterRequest)</span> &#123;</span><br><span class="line">  userService.save(userRegisterRequest);</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h2><h4 id="Value-常用"><a href="#Value-常用" class="headerlink" title="@Value(常用)"></a><code>@Value</code>(常用)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;wuhan2020&#125;&quot;)</span></span><br><span class="line">String wuhan2020;</span><br></pre></td></tr></table></figure>

<h4 id="ConfigurationProperties-常用"><a href="#ConfigurationProperties-常用" class="headerlink" title="@ConfigurationProperties(常用)"></a><code>@ConfigurationProperties</code>(常用)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibraryProperties</span> &#123;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        String description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PropertySource（不常用"><a href="#PropertySource（不常用" class="headerlink" title="@PropertySource（不常用)"></a><code>@PropertySource</code>（不常用)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:website.properties&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">  省略getter/setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><p> <strong>Hibernate Validator</strong> 框架</p>
<p><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</p>
<p><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</p>
<p><code>@Null</code> 被注释的元素必须为 null</p>
<p><code>@NotNull</code> 被注释的元素必须不为 null</p>
<p><code>@AssertTrue</code> 被注释的元素必须为 true</p>
<p><code>@AssertFalse</code> 被注释的元素必须为 false</p>
<p><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</p>
<p><code>@Email</code> 被注释的元素必须是 Email 格式。</p>
<p><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</p>
<p><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</p>
<p><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</p>
<p><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</p>
<p><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</p>
<p><code>@Digits(integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</p>
<p><code>@Past</code>被注释的元素必须是一个过去的日期</p>
<p><code>@Future</code> 被注释的元素必须是一个将来的日期</p>
<h2 id="全局处理-Controller-层异常"><a href="#全局处理-Controller-层异常" class="headerlink" title="全局处理 Controller 层异常"></a>全局处理 Controller 层异常</h2><p><strong>相关注解：</strong></p>
<ol>
<li><code>@ControllerAdvice</code> :注解定义全局异常处理类</li>
<li><code>@ExceptionHandler</code> :注解声明异常处理方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p><code>@Transactional</code> 是管理数据库事务的核心注解，正确使用它可以确保数据一致性。以下是详细的适用场景和使用指南</p>
<p>必须使用 <code>@Transactional</code> 的场景：</p>
<p>① 多数据库操作需要原子性时</p>
<p>② 需要保持数据一致性时</p>
<p>③ 需要特定隔离级别</p>
<p>推荐使用 <code>@Transactional</code> 的场景：</p>
<p>① 复杂的业务逻辑操作</p>
<p>② 需要审计日志的场景</p>
<p><code>@Transactional</code> 注解一般可以作用在<code>类</code>或者<code>方法</code>上</p>
<ul>
<li><strong>作用于类</strong>：当把<code>@Transactional</code> 注解放在类上时，表示所有该类的 public 方法都配置相同的事务属性信息。</li>
<li><strong>作用于方法</strong>：当类配置了<code>@Transactional</code>，方法也配置了<code>@Transactional</code>，方法的事务会覆盖类的事务配置信息</li>
</ul>
<h2 id="json-数据处理"><a href="#json-数据处理" class="headerlink" title="json 数据处理"></a>json 数据处理</h2><h3 id="过滤-json-数据"><a href="#过滤-json-数据" class="headerlink" title="过滤 json 数据"></a><strong>过滤 json 数据</strong></h3><p><strong><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析</strong></p>
<p><strong><code>@JsonIgnore</code>一般用于类的属性上，作用和上面的<code>@JsonIgnoreProperties</code> 一样</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;userRoles&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化-json-数据"><a href="#格式化-json-数据" class="headerlink" title="格式化 json 数据"></a>格式化 json 数据</h3><p><code>@JsonFormat</code>一般用来格式化 json 数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape=JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, timezone=&quot;GMT&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure>



<hr>
<hr>
<h2 id="star-重要总结"><a href="#star-重要总结" class="headerlink" title=":star: 重要总结"></a>:star: 重要总结</h2><h3 id="Ioc-Inversion-of-Control"><a href="#Ioc-Inversion-of-Control" class="headerlink" title="Ioc ( Inversion of Control )"></a>Ioc ( Inversion of Control )</h3><p>IoC （Inversion of Control ）即<span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;">控制反转&#x2F;反转控制</span>。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题</p>
<p>例如：现有类 A 依赖于类 B</p>
<ul>
<li><strong>传统的开发方式</strong> ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li>
<li><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是<span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;">通过 IoC 容器(Spring 框架) 来帮助我们实例化</span>对象。我们需要哪个对象，直接从 IoC 容器里面去取即可</li>
</ul>
<p><strong>为什么叫控制反转?</strong></p>
<ul>
<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong> ：控制权交给外部环境（IoC 容器）</li>
</ul>
<p><strong>IoC 解决了什么问题?</strong></p>
<p>IoC 的思想就是<span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;">两方之间不互相依赖，由第三方容器来管理相关资源我们将对象的控制权（创建、管理）交由 IoC 容器去管理</span>,这样有什么好处呢？</p>
<ol>
<li>对象之间的耦合度或者说依赖程度降低；</li>
<li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例</li>
</ol>
<h3 id="Ioc-DI"><a href="#Ioc-DI" class="headerlink" title="Ioc | DI"></a>Ioc | DI</h3><p>IoC（Inverse of Control:控制反转）是一种<span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;">设计思想或者说是某种模式</span>。这个设计思想就是 <span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;"><strong>将原本在程序中手动创建对象的控制权交给第三方比如 IoC 容器。</strong></span>* 对于我们常用的 Spring 框架来说， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。不过，IoC 在其他语言中也有应用，并非 Spring 特有。</p>
<p>IoC 最常见以及最合理的<span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;">*实现方式叫做依赖注入（Dependency Injection，简称 DI）</span></p>
<h3 id="AOP-2"><a href="#AOP-2" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（Aspect Oriented Programming）即<span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;">面向切面编程</span>，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。</p>
<p>AOP 的目的是<span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;">将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来</span>，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性</p>
<p>AOP 之所以叫面向切面编程，是因为它的核心思想就是将<span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;">横切关注点从核心业务逻辑中分离出来，形成一个个的<strong>切面（Aspect）</strong></span></p>
<p>AOP <span style="background: linear-gradient(transparent 50%, #00FF7F66 50%); padding: 0 2px;"><strong>关键术语</strong></span>：</p>
<ul>
<li><strong>横切关注点（cross-cutting concerns）</strong> ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。</li>
<li><strong>切面（Aspect）</strong>：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。</li>
<li><strong>连接点（JoinPoint）</strong>：连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。</li>
<li><strong>通知（Advice）</strong>：通知就是切面在某个连接点要执行的操作。通知有五种类型，分别是前置通知（Before）、后置通知（After）、返回通知（AfterReturning）、异常通知（AfterThrowing）和环绕通知（Around）。前四种通知都是在目标方法的前后执行，而环绕通知可以控制目标方法的执行过程。</li>
<li><strong>切点（Pointcut）</strong>：一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。切点可以通过注解、正则表达式、逻辑运算等方式来定义。比如 <code>execution(* com.xyz.service..*(..))</code>匹配 <code>com.xyz.service</code> 包及其子包下的类或接口。</li>
<li><strong>织入（Weaving）</strong>：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。常见的织入时机有两种，分别是编译期织入（Compile-Time Weaving 如：AspectJ）和运行期织入（Runtime Weaving 如：AspectJ、Spring AOP）。</li>
</ul>
<p>AOP 常见的 <span style="background: linear-gradient(transparent 50%, #00FF7F66 50%); padding: 0 2px;"><strong>通知类型</strong></span></p>
<ul>
<li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li>
<li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li>
<li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li>
<li><strong>AfterThrowing</strong>（异常通知）：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li>
<li><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li>
</ul>
<p>AOP  <span style="background: linear-gradient(transparent 50%, #00FF7F66 50%); padding: 0 2px;">解决的问题</span></p>
<p>OOP 不能很好地处理一些分散在多个类或对象中的公共行为（<span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;">如日志记录、事务管理、权限控制、接口限流、接口幂等等）</span>，这些行为通常被称为 <strong>横切关注点（cross-cutting concerns）</strong> 。如果我们在每个类或对象中都重复实现这些行为，那么会导致代码的冗余、复杂和难以维护</p>
<p>AOP 可以将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从 <strong>核心业务逻辑（core concerns，核心关注点）</strong> 中分离出来，实现关注点的分离</p>
<p>AOP <span style="background: linear-gradient(transparent 50%, #00FF7F66 50%); padding: 0 2px;">应用场景</span></p>
<ul>
<li>日志记录：自定义日志记录注解，利用 AOP，一行代码即可实现日志记录。</li>
<li>性能统计：利用 AOP 在目标方法的执行前后统计方法的执行时间，方便优化和分析。</li>
<li>事务管理：<code>@Transactional</code> 注解可以让 Spring 为我们进行事务管理比如回滚异常操作，免去了重复的事务管理逻辑。<code>@Transactional</code>注解就是基于 AOP 实现的。</li>
<li>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需要的权限，如果具备，就执行目标方法，否则就不执行。例如，SpringSecurity 利用<code>@PreAuthorize</code> 注解一行代码即可自定义权限校验。</li>
<li>接口限流：利用 AOP 在目标方法执行前通过具体的限流算法和实现对请求进行限流处理。</li>
<li>缓存管理：利用 AOP 在目标方法执行前后进行缓存的读取和更新。</li>
<li>……</li>
</ul>
<p>AOP <span style="background: linear-gradient(transparent 50%, #00FF7F66 50%); padding: 0 2px;">实现方式</span></p>
<p>AOP 的常见实现方式有动态代理、字节码操作等方式。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p>
<h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><p><span style="background: linear-gradient(transparent 50%, #FF000066 50%); padding: 0 2px;"><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong></span></p>
<p>事务的特性  <span style="background: linear-gradient(transparent 50%, #00FF7F66 50%); padding: 0 2px;">ACID</span></p>
<p><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p>
<p><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p>
<p><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p>
<p><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>
<p>Spring 支持两种方式的 <span style="background: linear-gradient(transparent 50%, #00FF7F66 50%); padding: 0 2px;">事务管理</span></p>
<ul>
<li><p>编程式事务：管理通过 <code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助</p>
</li>
<li><p>声明式事务管理：推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</p>
</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>工厂模式</li>
</ul>
<p>Spring 使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<ul>
<li>单例设计模式</li>
</ul>
<p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>
<p><strong>使用单例模式的好处</strong> :</p>
<p>① 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</p>
<p>② 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</p>
<ul>
<li>代理设计模式</li>
</ul>
<p><strong>AOP(Aspect-Oriented Programming，面向切面编程)</strong> 能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://system821.github.io">sptiz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://system821.github.io/2025/05/12/SpringBoot/">https://system821.github.io/2025/05/12/SpringBoot/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://system821.github.io" target="_blank">sptiz's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringBoot%E3%80%81%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/">SpringBoot、框架技术</a></div><div class="post-share"><div class="social-share" data-image="/img/forest_s.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/12/java%E6%96%B0%E7%89%B9%E6%80%A7/" title="java新特性"><img class="cover" src="/img/forest_s.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">java新特性</div></div><div class="info-2"><div class="info-item-1">Java新特性Java8Interfaceinterface的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。(结局办法是default或static修饰) 一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。  default修饰的方法，是普通实例方法，可以用this调用，可以被子类继承、重写。 static修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用Interface调用。  接口| 抽象类 interface 和 class 的区别，好像是废话，主要有： 接口多实现，类单继承 接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符   interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。  开始我们也提到，interface...</div></div></div></a><a class="pagination-related" href="/2025/05/13/mybatis/" title="mybatis"><img class="cover" src="/img/wale.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">mybatis</div></div><div class="info-2"><div class="info-item-1">Mybatis#{} 和 ${} 的区别是什么$&#123;&#125;是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于原样文本替换，可以替换任意内容，比如${driver}会被原样替换为&#96;com.mysql.jdbc. Driver #&#123;&#125;是 sql 的参数占位符，MyBatis 会将 sql 中的#&#123;&#125;替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，#&#123;item.name&#125; 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName() xml标签xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？ 答：还有很多其他的标签， &lt;resultMap&gt;、...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/13/mybatis/" title="mybatis"><img class="cover" src="/img/wale.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-13</div><div class="info-item-2">mybatis</div></div><div class="info-2"><div class="info-item-1">Mybatis#{} 和 ${} 的区别是什么$&#123;&#125;是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于原样文本替换，可以替换任意内容，比如${driver}会被原样替换为&#96;com.mysql.jdbc. Driver #&#123;&#125;是 sql 的参数占位符，MyBatis 会将 sql 中的#&#123;&#125;替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，#&#123;item.name&#125; 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName() xml标签xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？ 答：还有很多其他的标签， &lt;resultMap&gt;、...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">sptiz</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">自由散漫的无聊生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot"><span class="toc-number">1.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">核心模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Core-Container"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Core Container</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Access-Integration"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">Data Access&#x2F;Integration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Web"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">Spring Web</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Messaging"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">Messaging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Test"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">Spring Test</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Spring-MVC-Spring-Boot"><span class="toc-number">1.1.2.</span> <span class="toc-text">Spring | Spring MVC | Spring Boot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-IOC"><span class="toc-number">1.1.3.</span> <span class="toc-text">Spring IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean"><span class="toc-number">1.1.4.</span> <span class="toc-text">Spring Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA-Bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.5.</span> <span class="toc-text">将一个类声明为 Bean 的注解有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Component-Bean"><span class="toc-number">1.1.6.</span> <span class="toc-text">@Component | @Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5-Bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.7.</span> <span class="toc-text">注入 Bean 的注解有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5Bean%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.8.</span> <span class="toc-text">注入Bean的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-1"><span class="toc-number">1.1.9.</span> <span class="toc-text">AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">常用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBootApplication"><span class="toc-number">1.2.1.</span> <span class="toc-text">@SpringBootApplication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean-%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">Spring Bean 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Autowired"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">@Autowired</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Component-Repository-Service-Controller"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">@Component,@Repository,@Service, @Controller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RestController"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">@RestController</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scope"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">@Scope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Configuration"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">@Configuration</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%80%BC"><span class="toc-number">1.3.</span> <span class="toc-text">前后端传值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PathVariable-%E5%92%8C-RequestParam"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">@PathVariable 和 @RequestParam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RequestBody"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">@RequestBody</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.</span> <span class="toc-text">读取配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Value-%E5%B8%B8%E7%94%A8"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">@Value(常用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurationProperties-%E5%B8%B8%E7%94%A8"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">@ConfigurationProperties(常用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertySource%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">@PropertySource（不常用)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.5.</span> <span class="toc-text">参数校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%A4%84%E7%90%86-Controller-%E5%B1%82%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.</span> <span class="toc-text">全局处理 Controller 层异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional"><span class="toc-number">1.7.</span> <span class="toc-text">@Transactional</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">json 数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4-json-%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.1.</span> <span class="toc-text">过滤 json 数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96-json-%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.2.</span> <span class="toc-text">格式化 json 数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#star-%E9%87%8D%E8%A6%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">:star: 重要总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ioc-Inversion-of-Control"><span class="toc-number">1.9.1.</span> <span class="toc-text">Ioc ( Inversion of Control )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ioc-DI"><span class="toc-number">1.9.2.</span> <span class="toc-text">Ioc | DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-2"><span class="toc-number">1.9.3.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.9.4.</span> <span class="toc-text">Spring事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.9.5.</span> <span class="toc-text">设计模式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/%E6%9C%AC%E6%9C%BA%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/" title="本机资源配置"><img src="/img/configuration.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="本机资源配置"/></a><div class="content"><a class="title" href="/2025/10/22/%E6%9C%AC%E6%9C%BA%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/" title="本机资源配置">本机资源配置</a><time datetime="2025-10-22T02:31:29.000Z" title="发表于 2025-10-22 10:31:29">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/20/git%E4%B8%8A%E4%BC%A0/" title="git上传"><img src="/img/wale.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git上传"/></a><div class="content"><a class="title" href="/2025/10/20/git%E4%B8%8A%E4%BC%A0/" title="git上传">git上传</a><time datetime="2025-10-20T05:39:50.000Z" title="发表于 2025-10-20 13:39:50">2025-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/16/JWt/" title="SpringSecurity"><img src="/img/forest_s.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringSecurity"/></a><div class="content"><a class="title" href="/2025/05/16/JWt/" title="SpringSecurity">SpringSecurity</a><time datetime="2025-05-16T05:17:49.000Z" title="发表于 2025-05-16 13:17:49">2025-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/14/oauth2-0/" title="oauth2.0"><img src="/img/forest_s.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="oauth2.0"/></a><div class="content"><a class="title" href="/2025/05/14/oauth2-0/" title="oauth2.0">oauth2.0</a><time datetime="2025-05-14T10:06:31.000Z" title="发表于 2025-05-14 18:06:31">2025-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/13/mybatis/" title="mybatis"><img src="/img/wale.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mybatis"/></a><div class="content"><a class="title" href="/2025/05/13/mybatis/" title="mybatis">mybatis</a><time datetime="2025-05-12T16:56:59.000Z" title="发表于 2025-05-13 00:56:59">2025-05-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By sptiz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>